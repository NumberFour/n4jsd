import { EventEmitter } from "events"
import { Readable } from "stream"

/*
 * @see http://mongodb.github.io/node-mongodb-native/2.1/api
 */

export external public class MongoError {
    public constructor(message: string);
    @Override
    public static create(options: Object): MongoError;
}

export external public class MongoClient {
    public constructor();

    public static connect(
        url: string,
        options: union {
            MongoClientOptions,
            {function(err: MongoError, db: Db):void}
        } = undefined,
        callback: {function(err: MongoError, db: Db):void} = undefined
    ): Promise<Db, MongoError>;

    public connect(
        url: string,
        options: union {
            MongoClientOptions,
            {function(err: MongoError, db: Db):void}
        } = undefined,
        callback: {function(err: MongoError, db: Db):void} = undefined
    ): Promise<Db, MongoError>;
}

export external public interface MongoClientOptions {
    public uri_decode_auth?: boolean;
    public db?: DbCreateOptions;
    public server?: ServerOptions;
    public replSet?: ReplSetOptions;
    public mongos?: MongosOptions;
    public promiseLibrary?: Object;
}

export external public interface DbCreateOptions {
    public authSource?: string;
    public w?: union {number, string};
    public wtimeout?: number;
    public j?: boolean;
    public native_parser?: boolean;
    public forceServerObjectId?: boolean;
    public serializeFunctions?: boolean;
    public ignoreUndefined?: boolean;
    public raw?: boolean;
    public promoteLongs?: boolean;
    public bufferMaxEntries?: number;
    public readPreference?: union {ReadPreference, string};
    public pkFactory?: Object;
    public promiseLibrary?: Object;
    public readConcern?: ~Object with {
        level?: Object
    };
}

export external public class ReadPreference {
    static PRIMARY: string;
    static PRIMARY_PREFERRED: string;
    static SECONDARY: string;
    static SECONDARY_PREFERRED: string;
    static NEAREST: string;

    public constructor(mode: string, tags: Object);
    public mode: string;
    public tags: Object;

    public isValid(mode: string): boolean;
    public static isValid(mode: string): boolean;
}

export external public interface SocketOptions {
    public autoReconnect?: boolean;
    public noDelay?: boolean;
    public keepAlive?: int;
    public connectTimeoutMS?: int;
    public socketTimeoutMS?: int;
}

export external public interface ServerOptions {
    public poolSize?: int;
    public ssl?: boolean;
    public sslValidate?: Object;
    public checkServerIdentity?: union {boolean, Function};
    public sslCA?: Array<union {Buffer, string}>;
    public sslCert?: union {Buffer, string};
    public sslKey?: union {Buffer, string};
    public sslPass?: union {Buffer, string};
    public socketOptions?: SocketOptions;
    public reconnectTries?: int;
    public reconnectInterval?: int;
}

export external public interface ReplSetOptions {
    public ha?: boolean;
    public haInterval?: int;
    public replicaSet: string;
    public secondaryAcceptableLatencyMS?: int;
    public connectWithNoPrimary?: boolean;
    public poolSize?: int;
    public ssl?: boolean;
    public checkServerIdentity?: union {boolean, Function};
    public sslValidate?: Object;
    public sslCA?: Array<union {Buffer, string}>;
    public sslCert?: union {Buffer, string};
    public sslKey?: union {Buffer, string};
    public sslPass?: union {Buffer, string};
    public socketOptions?: SocketOptions;
}

export external public interface MongosOptions {
    public ha?: boolean;
    public haInterval?: int;
    public poolSize?: int;
    public ssl?: boolean;
    public checkServerIdentity: union {boolean, Function};
    public sslValidate?: Object;
    public sslCA?: Array<union {Buffer, string}>;
    public sslCert?: union {Buffer, string};
    public sslKey?: union {Buffer, string};
    public sslPass?: union {Buffer, string};
    public socketOptions?: SocketOptions;
}

export external public class Server extends EventEmitter {
    public constructor(host: string, port: union {number, ServerOptions} = undefined, options: ServerOptions = undefined);
    public connections(): Array<any>;
}

export external public class ReplSet extends EventEmitter {
    public constructor(servers: Array<Server>, options: ReplSetOptions = undefined);
    public connections(): Array<any>;
}

export external public class Mongos extends EventEmitter {
    public constructor(servers: Array<Server>, options: MongosOptions = undefined);
    public connections(): Array<any>;
}

export external public class Db extends EventEmitter {
    public constructor(databaseName: string, topology: union {Server, ReplSet, Mongos}, options: DbCreateOptions = undefined);
    public serverConfig: union {Server, ReplSet, Mongos};
    public bufferMaxEntries: int;
    public databaseName: string;
    public options: any;
    public native_parser: boolean;
    public slaveOk: boolean;
    public writeConcern: any;

    public addUser(
        username: string,
        password: string,
        options: union {
            ~Object with {
                w: union {number, string},
                wtimeout?: number,
                j?: boolean,
                customData?: Object,
                roles: Array<Object>
            },
            {function(error: MongoError, result: any)}
        } = undefined,
        callback: {function(error: MongoError, result: any)} = undefined
    ): Promise<any, MongoError>?;

    public admin(): Admin;

    public authenticate(
        username: string,
        password: union {
            string,
            ~Object with {authMechanism?: string},
            {function(error: MongoError, result: any)}
        } = undefined,
        options: union {
            ~Object with {authMechanism?: string},
            {function(error: MongoError, result: any)}
        } = undefined,
        callback: {function(error: MongoError, result: any)} = undefined
    ): Promise<any, MongoError>?;

    public close(force: boolean, callback: {function(error: MongoError)} = undefined): Promise<undefined, MongoError>?;

    public collection(
        name: string,
        options: union {
            ~Object with {
                w?: union {int, string},
                wtimeout?: int,
                j?: boolean,
                raw?: boolean,
                pkFactory?: Object,
                readPreference?: union {ReadPreference, string},
                serializeFunctions?: boolean,
                strict?: boolean,
                readConcern?: ~Object with {level?: Object}
            },
            {function(error: MongoError, collection: Collection)}
        } = undefined,
        callback: {function(error: MongoError, collection: Collection)} = undefined
    ): Collection?;

    public collections(callback: {function(error: MongoError, collections: Array<Collection>)} = undefined): Promise<Array<Collection>, MongoError>?;

    public command(
        command: Object,
        options: union {
            ~Object with {
                readPreference?: union {ReadPreference, string}
            },
            {function(error: MongoError, result: any)}
        } = undefined,
        callback: {function(error: MongoError, result: any)} = undefined
    ): Promise<any, MongoError>?;

    public createCollection(
        name: string,
        options: union {
            ~Object with {
                w: union {number, string},
                wtimeout: number,
                j: boolean,
                raw: boolean,
                pkFactory: Object,
                readPreference: union {ReadPreference, string},
                serializeFunctions: boolean,
                strict: boolean,
                capped: boolean,
                size: number,
                max: number,
                autoIndexId: boolean
            },
            {function(error: MongoError, collection: Collection)}
        } = undefined,
        callback: {function(error: MongoError, collection: Collection)} = undefined
    ): Promise<Collection, MongoError>?;

    public createIndex(
        name: string,
        fieldOrSpec: union {string, Object},
        options: union {IndexOptions,{function(error: MongoError, result: any)}} = undefined,
        callback: {function(error: MongoError, result: any)} = undefined
    ): Promise<any, MongoError>?;

    public db(
        name: string,
        options: ~Object with {
            noListener?: boolean,
            returnNonCachedInstance?: boolean
        }
    ): Db;

    public dropCollection(name: string, callback: {function(error: MongoError, result: any)} = undefined): Promise<any, MongoError>?;

    public dropDatabase(callback: {function(error: MongoError, result: any)} = undefined): Promise<any, MongoError>?;

    public executeDbAdminCommand(
        command: Object,
        options: union {
            ~Object with {
                readPreference?: union {ReadPreference, string},
                maxTimeMS?: int
            },
            {function(error: MongoError, result: any)}
        } = undefined,
        callback: {function(error: MongoError, result: any)} = undefined
    ): Promise<any, MongoError>?;

    public indexInformation(
        name: string,
        options: union {
            ~Object with {
                readPreference?: union {ReadPreference, string},
                full?: boolean
            },
            {function(error: MongoError, result: any)}
        } = undefined,
        callback: {function(error: MongoError, result: any)} = undefined
    ): Promise<any, MongoError>?;

    public listCollections(
        filter: Object,
        options: ~Object with {
            batchSize?:int,
            readPreference?: union {ReadPreference, string}
        } = undefined
    ): CommandCursor;

    public logout(
        options: union {
            ~Object with {
                dbName?: string
            },
            {function(error: MongoError, result: any)}
        } = undefined,
        callback: {function(error: MongoError, result: any)} = undefined
    ): Promise<any, MongoError>?;

    public open(callback: {function(error: MongoError, db: Db)} = undefined): Promise<Db, MongoError>?;

    public removeUser(
        username: string,
        options: union {CollectionOptions, {function(error: MongoError, result: any)}} = undefined,
        callback: {function(error: MongoError, result: any)} = undefined
    ): Promise<any, MongoError>?;

    public renameCollection(
        fromCollection: string,
        toCollection: string,
        options: union {
            ~Object with {
                dropTarget?: boolean
            },
            {function(error: MongoError, collection: Collection)}
        } = undefined,
        callback: {function(error: MongoError, collection: Collection)} = undefined
    ): Promise<Collection, MongoError>?;

    public stats(
        options: union {
            ~Object with {
                scale?: number
            },
            {function(error: MongoError, result: any)}
        } = undefined,
        callback: {function(error: MongoError, result: any)} = undefined
    ): Promise<any, MongoError>?;
}

export external public interface Admin {
    public addUser(
        username: string,
        password: string,
        options: union {
            ~Object with {
                w: union {number, string},
                wtimeout?: number,
                j?: boolean,
                fsync?: boolean,
                customData?: Object,
                roles: Array<Object>
            },
            {function(error: MongoError, result: any)}
        } = undefined,
        callback: {function(error: MongoError, result: any)} = undefined
    ): Promise<any, MongoError>?;

    public authenticate(
        username: string,
        password: union {
            string,
            {function(error: MongoError, result: any)}
        } = undefined,
        callback: {function(error: MongoError, result: any)} = undefined
    ): Promise<any, MongoError>?;

    public buildInfo(callback: {function(error: MongoError, result: any)} = undefined): Promise<any, MongoError>?;

    public command(
        command: Object,
        options: union {
            ~Object with {
                readPreference?: union {ReadPreference, string},
                maxTimeMS?: number
            },
            {function(error: MongoError, result: any)}
        } = undefined,
        callback: {function(error: MongoError, result: any)} = undefined
    ): Promise<any, MongoError>?;

    public listDatabases(callback: {function(error: MongoError, result: any)} = undefined): Promise<any, MongoError>?;
    public logout(callback: {function(error: MongoError, result: any)} = undefined): Promise<any, MongoError>?;
    public ping(callback: {function(error: MongoError, result: any)} = undefined): Promise<any, MongoError>?;
    public profilingInfo(callback: {function(error: MongoError, result: any)} = undefined): Promise<any, MongoError>?;
    public profilingLevel(callback: {function(error: MongoError, result: any)} = undefined): Promise<any, MongoError>?;
    public replSetGetStatus(callback: {function(error: MongoError, result: any)} = undefined): Promise<any, MongoError>?;
    public serverInfo(callback: {function(error: MongoError, result: any)} = undefined): Promise<any, MongoError>?;
    public serverStatus(callback: {function(error: MongoError, result: any)} = undefined): Promise<any, MongoError>?;
    public setProfilingLevel(level: string, callback: {function(error: MongoError, result: any)} = undefined): Promise<any, MongoError>?;

    public removeUser(
        username: string,
        options: union {
            ~Object with {
                w?: union {number, string},
                wtimeout?: int,
                j?: boolean,
                fsync?: boolean
            },
            {function(error: MongoError, result: any)}
        } = undefined,
        callback: {function(error: MongoError, result: any)} = undefined
    ): Promise<any, MongoError>?;

    public validateCollection(
        collectionName: string,
        options: union {Object, {function(error: MongoError, result: any)}} = undefined,
        callback: {function(error: MongoError, result: any)} = undefined
    ): Promise<any, MongoError>?;
}

export external public interface Collection {
    public collectionName: string;
    public namespace: string;
    public writeConcern: any;
    public readConcern: any;
    public hint: any;

    public aggregate(
        pipeline: Array<Object>,
        options: union {
            ~Object with {
                readPreference?: union {ReadPreference, string},
                cursor?: ~Object with {
                    batchSize?: number
                },
                explain?: boolean,
                allowDiskUse?: boolean,
                maxTimeMS?: number,
                bypassDocumentValidation?: boolean,
            },
            {function(error: MongoError, result: any)}
        } = undefined,
        callback: {function(error: MongoError, result: any)} = undefined
    ): AggregationCursor?;

    public bulkWrite(
        operations: Array<Object>,
        options: union {
            ~Object with {
                w?: union{number, string},
                wtimeout?: number,
                j?: boolean,
                serializeFunctions?: boolean,
                ordered?: boolean,
                bypassDocumentValidation?: boolean
            },
            {function(error: MongoError, result: BulkWriteOpResultObject)}
        } = undefined,
        callback: {function(error: MongoError, result: BulkWriteOpResultObject)} = undefined
    ): Promise<BulkWriteOpResultObject, MongoError>?;

    public count(
        query: Object,
        options: union {
            ~Object with {
                readPreference?: union {ReadPreference, string},
                limit?: boolean,
                skip?: boolean,
                hint?: boolean,
            },
            {function(error: MongoError, result: int)}
        } = undefined,
        callback: {function(error: MongoError, result: int)} = undefined
    ): Promise<int, MongoError>?;

    public createIndex(
        fieldOrSpec: union{Object, string},
        options: union {IndexOptions, {function(error: MongoError, result: any)}} = undefined,
        callback: {function(error: MongoError, result: any)} = undefined
    ): Promise<any, MongoError>?;

    public createIndexes(indexSpecs: Array<Object>, callback: {function(error: MongoError, result: any)} = undefined): Promise<any, MongoError>?;

    public deleteMany(
        filter: Object,
        options: union {CollectionOptions, {function(error: MongoError, result: DeleteWriteOpResultObject)}} = undefined,
        callback: {function(error: MongoError, result: DeleteWriteOpResultObject)} = undefined
    ): Promise<DeleteWriteOpResultObject, MongoError>?;

    public deleteOne(
        filter: Object,
        options: union {CollectionOptions, {function(error: MongoError, result: DeleteWriteOpResultObject)}} = undefined,
        callback: {function(error: MongoError, result: DeleteWriteOpResultObject)} = undefined
    ): Promise<DeleteWriteOpResultObject, MongoError>?;

    public distinct(
        key: string,
        query: Object,
        options: union {
            ~Object with {
                readPreference?: union {ReadPreference, string}
            },
            {function(error: MongoError, result: any)}
        } = undefined,
        callback: {function(error: MongoError, result: any)} = undefined
    ): Promise<any, MongoError>?;

    public drop(callback: {function(error: MongoError, result: any)} = undefined): Promise<any, MongoError>?;

    public dropIndex(
        indexName: string,
        options: union {CollectionOptions, {function(error: MongoError, result: any)}} = undefined,
        callback: {function(error: MongoError, result: any)} = undefined
    ): Promise<any, MongoError>?;

    public dropIndexes(callback: {function(error: MongoError, result: any)} = undefined): Promise<any, MongoError>?;
    public find(query: Object): Cursor;

    public findOneAndDelete(
        filter: Object,
        options: union {
            ~Object with {
                projection?: Object,
                sort?: Object,
                maxTimeMS?: number
            },
            {function(error: MongoError, result: FindAndModifyWriteOpResultObject)}
        } = undefined,
        callback: {function(error: MongoError, result: FindAndModifyWriteOpResultObject)} = undefined
    ): Promise<FindAndModifyWriteOpResultObject, MongoError>?;

    public findOneAndReplace(
        filter: Object,
        replacement: Object,
        options: union {
            ~Object with {
                projection?: Object,
                sort?: Object,
                maxTimeMS?: number,
                upsert?: boolean,
                returnOriginal?: boolean
            },
            {function(error: MongoError, result: FindAndModifyWriteOpResultObject)}
        } = undefined,
        callback: {function(error: MongoError, result: FindAndModifyWriteOpResultObject)} = undefined
    ): Promise<FindAndModifyWriteOpResultObject, MongoError>?;

    public findOneAndUpdate(
        filter: Object,
        update: Object,
        options: union {
            ~Object with {
                projection?: Object,
                sort?: Object,
                maxTimeMS?: number,
                upsert?: boolean,
                returnOriginal?: boolean
            },
            {function(error: MongoError, result: FindAndModifyWriteOpResultObject)}
        } = undefined,
        callback: {function(error: MongoError, result: FindAndModifyWriteOpResultObject)} = undefined
    ): Promise<FindAndModifyWriteOpResultObject, MongoError>?;

    public geoHaystackSearch(
        x: number,
        y: number,
        options: union {
            ~Object with {
                readPreference?: union {ReadPreference, string},
                maxDistance?: number,
                search?: Object,
                limit?: number
            },
            {function(error: MongoError, result: any)}
        } = undefined,
        callback: {function(error: MongoError, result: any)} = undefined
    ): Promise<any, MongoError>?;

    public geoNear(
        x: number,
        y: number,
        options: union {
            ~Object with {
                readPreference?: union {ReadPreference, string},
                num?: number,
                minDistance?: number,
                maxDistance?: number,
                distanceMultiplier?: number,
                query?: Object,
                spherical?: boolean
                uniqueDocs?: boolean
                includeLocs?: boolean
            },
            {function(error: MongoError, result: any)}
        } = undefined,
        callback: {function(error: MongoError, result: any)} = undefined
    ): Promise<any, MongoError>?;

    public group(
        keys: union {Object, Array<any>, Function, Code},
        condition: Object,
        initial: Object,
        reduce: union {Function, Code},
        finalize: union {Function, Code},
        command: boolean,
        options: union {
            ~Object with {
                readPreference?: union {ReadPreference, string}
            },
            {function(error: MongoError, result: any)}
        } = undefined,
        callback: {function(error: MongoError, result: any)} = undefined
    ): Promise<any, MongoError>?;

    public indexes(callback: {function(error: MongoError, result: any)} = undefined): Promise<any, MongoError>?;
    public indexExists(indexes: union {string, Array<string>}, callback: {function(error: MongoError, result: any)} = undefined): Promise<any, MongoError>?;

    public indexInformation(
        options: union {
            ~Object with {
                full?: boolean
            },
            {function(error: MongoError, result: any)}
        } = undefined,
        callback: {function(error: MongoError, result: any)} = undefined
    ): Promise<any, MongoError>?;

    public initializeOrderedBulkOp(
        options: union {CollectionOptions, {function(error: MongoError, result: OrderedBulkOperation)}} = undefined,
        callback: {function(error: MongoError, result: OrderedBulkOperation)} = undefined
    ): void;

    public initializeUnorderedBulkOp(options: CollectionOptions = undefined): UnorderedBulkOperation;

    public insertMany(
        docs: Array<Object>,
        options: union {
            ~Object with {
                w?: union{number, string},
                wtimeout?: number,
                j?: boolean,
                serializeFunctions?: boolean,
                forceServerObjectId?: boolean,
                bypassDocumentValidation?: boolean
            },
            {function(error: MongoError, result: InsertWriteOpResultObject)}
        } = undefined,
        callback: {function(error: MongoError, result: InsertWriteOpResultObject)} = undefined
    ): Promise<InsertWriteOpResultObject, MongoError>?;

    public insertOne(
        doc: Object,
        options: union {
            ~Object with {
                w?: union{number, string},
                wtimeout?: number,
                j?: boolean,
                serializeFunctions?: boolean,
                forceServerObjectId?: boolean,
                bypassDocumentValidation?: boolean
            },
            {function(error: MongoError, result: InsertOneWriteOpResultObject)}
        } = undefined,
        callback: {function(error: MongoError, result: InsertOneWriteOpResultObject)} = undefined
    ): Promise<InsertOneWriteOpResultObject, MongoError>?;

    public isCapped(callback: {function(error: MongoError, result: any)} = undefined): Promise<any, MongoError>?;

    public listIndexes(options: ~Object with {
        batchSize?: number,
        readPreference?: union {ReadPreference, string}
    } = undefined): CommandCursor;

    public mapReduce(
        map: union{Function, string},
        reduce: union{Function, string},
        options: union {
            ~Object with {
                readPreference?: union {ReadPreference, string},
                out?: Object,
                query?: Object,
                sort?: Object,
                limit?: number,
                keeptemp?: boolean,
                finalize?: union{Function, string},
                scope?: Object,
                jsMode?: boolean,
                verbose?: boolean,
                bypassDocumentValidation?: boolean
            },
            {function(error: MongoError, result: any)}
        } = undefined,
        callback: {function(error: MongoError, result: any)} = undefined
    ): Promise<any, MongoError>?;

    public options(callback: {function(error: MongoError, result: any)} = undefined): Promise<any, MongoError>?;

    public parallelCollectionScan(
        options: union {
            ~Object with {
                readPreference?: union {ReadPreference, string},
                batchSize?: number,
                numCursors?: number,
                raw?: boolean,
            },
            {function(error: MongoError, result: Array<Cursor>)}
        } = undefined,
        callback: {function(error: MongoError, result: Array<Cursor>)} = undefined
    ): Promise<Array<Cursor>, MongoError>?;

    public reIndex(callback: {function(error: MongoError, result: any)} = undefined): Promise<any, MongoError>?;

    public rename(
        newName: string,
        options: union {
            ~Object with {
                dropTarget?: boolean,
            },
            {function(error: MongoError, result: Collection)}
        } = undefined,
        callback: {function(error: MongoError, result: Collection)} = undefined
    ): Promise<Collection, MongoError>?;

    public replaceOne(
        filter: Object,
        doc: Object,
        options: union {
            ~Object with {
                upsert?: boolean,
                w?: union{number, string},
                wtimeout?: number,
                j?: boolean,
                bypassDocumentValidation?: boolean
            },
            {function(error: MongoError, result: UpdateWriteOpResultObject)}
        } = undefined,
        callback: {function(error: MongoError, result: UpdateWriteOpResultObject)} = undefined
    ): Promise<UpdateWriteOpResultObject, MongoError>?;

    public stats(
        options: union {
            ~Object with {
                scale?: number
            },
            {function(error: MongoError, result: any)}
        } = undefined,
        callback: {function(error: MongoError, result: any)} = undefined
    ): Promise<any, MongoError>?;

    public updateMany(
        filter: Object,
        update: Object,
        options: union {
            ~Object with {
                upsert?: boolean,
                w?: union{number, string},
                wtimeout?: number,
                j?: boolean,
            },
            {function(error: MongoError, result: UpdateWriteOpResultObject)}
        } = undefined,
        callback: {function(error: MongoError, result: UpdateWriteOpResultObject)} = undefined
    ): Promise<UpdateWriteOpResultObject, MongoError>?;

    public updateOne(
        filter: Object,
        update: Object,
        options: union {
            ~Object with {
                upsert?: boolean,
                w?: union{number, string},
                wtimeout?: number,
                j?: boolean,
                bypassDocumentValidation?: boolean
            },
            {function(error: MongoError, result: UpdateWriteOpResultObject)}
        } = undefined,
        callback: {function(error: MongoError, result: UpdateWriteOpResultObject)} = undefined
    ): Promise<UpdateWriteOpResultObject, MongoError>?;
}


export external public interface OrderedBulkOperation {
    public length: int;
    public execute(
        options: union {
            ~Object with {
                upsert?: boolean,
                w?: union{number, string},
                wtimeout?: number,
                j?: boolean,
                fsync?: boolean
            },
            {function(error: MongoError, result: BulkWriteResult)}
        } = undefined,
        callback: {function(error: MongoError, result: BulkWriteResult)} = undefined
    ): Promise<BulkWriteResult, MongoError>?;

    public find(selector: Object): FindOperatorsOrdered;
    public insert(doc: Object): OrderedBulkOperation;
}

export external public interface BulkWriteResult {
    public ok: boolean;
    public nInserted: number;
    public nUpdated: number;
    public nUpserted: number;
    public nModified: number;
    public nRemoved: number;

    public getInsertedIds(): Array<Object>;
    public getLastOp(): Object;
    public getRawResponse(): Object;
    public getUpsertedIdAt(index: number): Object;
    public getUpsertedIds(): Array<Object>;
    public getWriteConcernError(): WriteConcernError;
    public getWriteErrorAt(index: number): WriteError;
    public getWriteErrorCount(): number;
    public getWriteErrors(): Array<Object>;
    public hasWriteErrors(): boolean;
}

export external public interface WriteError {
    code: number;
    index: number;
    errmsg: string;
}

export external public interface WriteConcernError {
    code: number;
    errmsg: string;
}

export external public interface FindOperatorsOrdered {
    delete(): OrderedBulkOperation;
    deleteOne(): OrderedBulkOperation;
    replaceOne(doc: Object): OrderedBulkOperation;
    update(doc: Object): OrderedBulkOperation;
    updateOne(doc: Object): OrderedBulkOperation;
    upsert(): FindOperatorsOrdered;
}

export external public interface FindOperatorsUnordered {
    length: int;
    remove(): UnorderedBulkOperation;
    removeOne(): UnorderedBulkOperation;
    replaceOne(doc: Object): UnorderedBulkOperation;
    update(doc: Object): UnorderedBulkOperation;
    updateOne(doc: Object): UnorderedBulkOperation;
    upsert(): FindOperatorsUnordered;
}

export external public interface UnorderedBulkOperation {
    public execute(
        options: union {
            ~Object with {
                w?: union{number, string},
                wtimeout?: number,
                j?: boolean,
                fsync?: boolean
            },
            {function(error: MongoError, result: BulkWriteResult)}
        } = undefined,
        callback: {function(error: MongoError, result: BulkWriteResult)} = undefined
    ): Promise<BulkWriteResult, MongoError>?;

    public find(selector: Object): FindOperatorsUnordered;
    public insert(doc: Object): UnorderedBulkOperation;
}

export external public class Cursor extends Readable {
    private constructor();
    public sortValue: string;
    public timeout: boolean;
    public readPreference: ReadPreference;

    public addCursorFlag(flag: string, value: boolean): Cursor;
    public addQueryModifier(name: string, value: boolean): Cursor;
    public batchSize(value: number): Cursor;
    public clone(): Cursor;
    public close(callback: {function(error: MongoError, result: union{undefined, Object, boolean})} = undefined): Promise<union{undefined, Object, boolean}, MongoError>?;
    public comment(value: string): Cursor;

    public count(
        applySkipLimit: boolean,
        options: union {
            ~Object with {
                readPreference?: union {ReadPreference, string},
                limit?: boolean,
                skip?: boolean,
                hint?: boolean,
                maxTimeMS?: number
            },
            {function(error: MongoError, result: number)}
        } = undefined,
        callback: {function(error: MongoError, result: number)} = undefined
    ): Promise<number, MongoError>?;

    public explain(callback: {function(error: MongoError, result: union{undefined, Object, boolean})} = undefined): Promise<union{undefined, Object, boolean}, MongoError>?;
    public filter(filter: Object): Cursor;
    public forEach(iterator: {function(doc:Object)}, callback: {function(error:MongoError)}): void;
    public hasNext(callback: {function(error: MongoError, result: union{undefined, Object, boolean})} = undefined): Promise<union{undefined, Object, boolean}, MongoError>?;
    public hint(hint: Object): Cursor;
    public isClosed(): boolean;
    public limit(value: number): Cursor;
    public map(transform: Function): void;
    public min(min: Object): Cursor;
    public max(max: Object): Cursor;
    public maxAwaitTimeMS(value: number): Cursor;
    public maxTimeMS(value: number): Cursor;
    public maxScan(maxScan: Object): Cursor;
    public next(callback: {function(error: MongoError, result: union{undefined, Object, boolean})} = undefined): Promise<union{undefined, Object, boolean}, MongoError>?;
    public setCursorOption(field: string, value: Object): Cursor;
    public setReadPreference(readPreference: union {string, ReadPreference}): Cursor;
    public showRecordId(showRecordId: Object): Cursor;
    public skip(value: number): Cursor;
    public snapshot(snapshot: Object): Cursor;
    public sort(keyOrList: union{string, Array<any>, Object}, direction: number = undefined): Cursor;
    public stream(options: ~Object with { transform?: Function} = undefined): Cursor;
    public toArray(callback: {function(error: MongoError, documents: Array<Object>)} = undefined): Promise<Array<Object>, MongoError>?;
}

export external public class AggregationCursor extends Readable {
    private constructor();

    public batchSize(value: number): AggregationCursor;
    public clone(): AggregationCursor;
    public close(callback: {function(error: MongoError, result: union{undefined, Object})} = undefined): Promise<union{undefined, Object}, MongoError>?;
    public each(callback: {function(error: MongoError, result: union{undefined, Object})}): void
    public explain(callback: {function(error: MongoError, result: union{undefined, Object})} = undefined): Promise<union{undefined, Object}, MongoError>?;
    public geoNear(document: Object): AggregationCursor;
    public group(document: Object): AggregationCursor;
    public isClosed(): boolean;
    public limit(value: number): AggregationCursor;
    public match(document: Object): AggregationCursor;
    public maxTimeMS(value: number): AggregationCursor;
    public next(callback: {function(error: MongoError, result: union{undefined, Object})} = undefined): Promise<union{undefined, Object}, MongoError>?;
    public out(destination: number): AggregationCursor;
    public project(document: Object): AggregationCursor;
    public redact(document: Object): AggregationCursor;
    public rewind(): AggregationCursor;
    public skip(value: number): AggregationCursor;
    public sort(document: Object): AggregationCursor;
    public toArray(callback: {function(error: MongoError, documents: Array<Object>)} = undefined): Promise<Array<Object>, MongoError>?;
    public unwind(field: string): AggregationCursor;
}

export external public class CommandCursor extends Readable {
    private constructor();

    public batchSize(value: number): CommandCursor;
    public clone(): CommandCursor;
    public close(callback: {function(error: MongoError, result: union{undefined, Object})} = undefined): Promise<union{undefined, Object}, MongoError>?;
    public each(callback: {function(error: MongoError, result: union{undefined, Object})}): void
    public isClosed(): boolean;
    public maxTimeMS(value: number): CommandCursor;
    public next(callback: {function(error: MongoError, result: union{undefined, Object})} = undefined): Promise<union{undefined, Object}, MongoError>?;
    public rewind(): CommandCursor;
    public setReadPreference(readPreference: union{string, ReadPreference}): CommandCursor;
    public toArray(callback: {function(error: MongoError, documents: Array<Object>)} = undefined): Promise<Array<Object>, MongoError>?;
}

export external public class Code {
    public constructor(code: union {string, Function}, scope:Object = undefined);
    public code: union {string, Function};
    public scope: any;
}

export external public interface CollectionOptions {
    public w?: union{number, string};
    public wtimeout?: number;
    public j?: boolean;
}

export external public interface IndexOptions {
    public w?: union{number, string};
    public wtimeout?: number;
    public j?: boolean;
    public unique?: boolean;
    public sparse?: boolean;
    public background?: boolean;
    public dropDups?: boolean;
    public min?: number;
    public max?: number;
    public v?: number;
    public expireAfterSeconds?: number;
    public name?: number;
}

export external public interface UpdateWriteOpResultObject {
    public result: ~Object with {
        ok: number,
        n: number,
        nModified: number
    };
    public connection: any;
    public matchedCount: number;
    public modifiedCount: number;
    public upsertedCount: number;
    public upsertedId: ~Object with {
        _id: ObjectID
    };
}
export external public interface FindAndModifyWriteOpResultObject {
    public value?: Object;
    public lastErrorObject?: Object;
    public ok?: int;
}

export external public interface InsertOneWriteOpResultObject {
    public insertedCount: number;
    public ops: Array<any>;
    public insertedId: ObjectID;
    public connection: any;
    public result: ~ Object with {
        ok: number,
        n: number
    };
}

export external public interface InsertWriteOpResultObject {
    public insertedCount: number;
    public ops: Array<any>;
    public insertedIds: Array<ObjectID>;
    public connection: any;
    public result: ~ Object with {
        ok: number,
        n: number
    };
}

export external public interface DeleteWriteOpResultObject {
    public result?: ~Object with {
        ok: number;
        n: number;
    };
    public connection?: Object;
    public deletedCount?: int;
}

export external public interface BulkWriteOpResultObject {
    public insertedCount?: number;
    public matchedCount?: number;
    public modifiedCount?: number;
    public deletedCount?: number;
    public upsertedCount?: number;
    public insertedIds?: any;
    public upsertedIds?: any;
    public result?: any;
}

export external public class ObjectID {
    public constructor(id: union {string, number});
    public generationTime: number;
    public static createFromHexString(hexString: string): ObjectID;
    public static createFromTime(time: number): ObjectID;
    public static isValid(): boolean;
    public equals(otherId: ObjectID): boolean;
    public generate(time: number): string;
    public getTimestamp(): Date;
    public toHexString(): string;
}

export external public class Binary {
    public constructor(buffer: Buffer, subType: number = undefined);

    static SUBTYPE_BYTE_ARRAY: number;
    static SUBTYPE_DEFAULT: number;
    static SUBTYPE_FUNCTION: number;
    static SUBTYPE_MD5: number;
    static SUBTYPE_USER_DEFINED: number;
    static SUBTYPE_UUID: number;
    static SUBTYPE_UUID_OLD: number;

    public length(): number;
    public put(byte_value: string): void;
    public read(position: number, length: number): Buffer;
    public value(): string;
    public write(buffer: union{Buffer, string}, offset: number): void;
}

export external public class Double {
    public constructor(value: number);
    @Override
    public valueOf(): number;
}

export external public class Long {
    public constructor(low: number, high: number);

    public static MAX_VALUE: Long;
    public static MIN_VALUE: Long;
    public static NEG_ONE: Long;
    public static ONE: Long;
    public static ZERO: Long;

    public static fromBits(lowBits: number, highBits: number): Long;
    public static fromInt(value: int): Long;
    public static fromNumber(value: number): Long;
    public static fromString(str: string, opt_radix: number): Long;

    public add(other: Long): Long;
    public and(other: Long): Long;
    public compare(other: Long): number;
    public div(other: Long): Long;
    public equals(other: Long): boolean;
    public getHighBits(): number;
    public getLowBits(): number;
    public getLowBitsUnsigned(): number;
    public getNumBitsAbs(): number;
    public greaterThan(other: Long): boolean;
    public greaterThanOrEqual(other: Long): boolean;
    public isNegative(): boolean;
    public isOdd(): boolean;
    public isZero(): boolean;
    public lessThan(other: Long): boolean;
    public lessThanOrEqual(other: Long): boolean;
    public modulo(other: Long): Long;
    public multiply(other: Long): Long;
    public negate(): Long;
    public not(): Long;
    public notEquals(other: Long): boolean;
    public or(other: Long): Long;
    public shiftLeft(numBits: number): Long;
    public shiftRight(numBits: number): Long;
    public shiftRightUnsigned(numBits: number): Long;
    public subtract(other: Long): Long;
    public toInt(): number;
    public toJSON(): string;
    public toNumber(): number;
    @Override
    public toString(opt_radix: number = undefined): string;
    public xor(other: Long): Long;
}

export external public class MaxKey {
    public constructor();
}
export external public class MinKey {
    public constructor();
}
export external public class Timestamp {
    public constructor(low: number, high: number);

    public static MAX_VALUE: Timestamp;
    public static MIN_VALUE: Timestamp;
    public static NEG_ONE: Timestamp;
    public static ONE: Timestamp;
    public static ZERO: Timestamp;

    public static fromBits(lowBits: number, highBits: number): Timestamp;
    public static fromInt(value: int): Timestamp;
    public static fromNumber(value: number): Timestamp;
    public static fromString(str: string, opt_radix: number): Timestamp;

    public add(other: Timestamp): Timestamp;
    public and(other: Timestamp): Timestamp;
    public compare(other: Timestamp): number;
    public div(other: Timestamp): Timestamp;
    public equals(other: Timestamp): boolean;
    public getHighBits(): number;
    public getLowBits(): number;
    public getLowBitsUnsigned(): number;
    public getNumBitsAbs(): number;
    public greaterThan(other: Timestamp): boolean;
    public greaterThanOrEqual(other: Timestamp): boolean;
    public isNegative(): boolean;
    public isOdd(): boolean;
    public isZero(): boolean;
    public lessThan(other: Timestamp): boolean;
    public lessThanOrEqual(other: Timestamp): boolean;
    public modulo(other: Timestamp): Timestamp;
    public multiply(other: Timestamp): Timestamp;
    public negate(): Timestamp;
    public not(): Timestamp;
    public notEquals(other: Timestamp): boolean;
    public or(other: Timestamp): Timestamp;
    public shiftLeft(numBits: number): Timestamp;
    public shiftRight(numBits: number): Timestamp;
    public shiftRightUnsigned(numBits: number): Timestamp;
    public subtract(other: Timestamp): Timestamp;
    public toInt(): number;
    public toJSON(): string;
    public toNumber(): number;
    @Override
    public toString(opt_radix: number = undefined): string;
    public xor(other: Timestamp): Timestamp;
}

/* -*- mode: typescript;-*- */
